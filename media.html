

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover" />
  <title>Media Player</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background-color: #0f0f0f;
      color: #ffffff;
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
      touch-action: manipulation;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
      width: 100%;
      max-width: 100vw;
      height: 100vh;
      max-height: 100vh;
      zoom: 1;
      -webkit-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      text-size-adjust: 100%;
      user-zoom: fixed;
      -webkit-user-zoom: fixed;
      -moz-user-zoom: fixed;
    }
    iframe {
      border: none;
      width: 100vw;
      height: calc(100vh - 60px);
      position: fixed;
      top: 60px;
      left: 0;
      z-index: 1;
    }
    .caption-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      background: linear-gradient(to bottom, rgba(15,15,15,0.95), rgba(15,15,15,0.7));
      backdrop-filter: blur(10px);
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1rem;
      min-height: 60px;
    }
    .caption-bar h1 {
      font-size: 1rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.25rem;
      white-space: nowrap;
    }
    .caption-bar .controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: nowrap;
    }
    #timeDisplay {
      font-size: 0.9rem;
      color: #f56d6d;
      font-family: monospace;
      min-width: 65px;
    }
    .loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2rem;
      font-weight: bold;
      color: white;
      z-index: 100;
    }
    #nextEpisodeUI {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0,0,0,0.8);
      padding: 2rem;
      text-align: center;
      color: white;
      display: none;
      z-index: 150;
      border-radius: 1rem;
      max-width: 80%;
      backdrop-filter: blur(10px);
    }

    @media (max-width: 768px) {
      .caption-bar {
        padding: 0.5rem 0.75rem;
        min-height: 50px;
        width: 100%;
        max-width: 100vw;
        box-sizing: border-box;
      }

      iframe {
        height: calc(100vh - 50px);
        top: 50px;
        width: 100vw;
        max-width: 100vw;
      }

      .caption-bar h1 {
        font-size: 0.85rem;
      }

      .caption-bar .controls {
        gap: 0.25rem;
        flex-wrap: nowrap;
        overflow: hidden;
      }

      #timeDisplay {
        font-size: 0.75rem;
        min-width: 55px;
      }

      .caption-bar button {
        font-size: 0.7rem !important;
        padding: 0.2rem 0.4rem !important;
      }

      #prevEpisodeBtn, #nextEpisodeBtn {
        font-size: 0.65rem !important;
        padding: 0.25rem 0.5rem !important;
      }

      #nextEpisodeUI {
        padding: 1.5rem;
        max-width: 90%;
      }

      #infoPanel {
        max-width: 95% !important;
        padding: 1.5rem !important;
        font-size: 0.9rem;
      }

      #infoPanel h2 {
        font-size: 1.2rem !important;
      }

      #infoPanel h3 {
        font-size: 1rem !important;
      }
    }
    #progressBar {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 4px;
      background: rgba(128, 128, 128, 0.5);
      z-index: 99;
    }
    #progressFill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #8b5cf6, #6366f1);
      transition: width 0.5s;
    }
  </style>
</head>
<body>
  <div class="caption-bar">
    <button onclick="saveProgress(); window.location.href='index.html'" style="background: none; border: none; color: white; font-size: 1.2rem; cursor: pointer; padding: 0.25rem;">&#8592;</button>
    <h1>❄ Lumina</h1>
    <div class="controls">
      <button id="prevEpisodeBtn" onclick="playPrevEpisode()" style="display: none; background: rgba(26, 26, 26, 0.8); border: 1px solid #444; color: white; padding: 0.3rem 0.6rem; border-radius: 0.4rem; margin-right: 0.5rem; cursor: pointer; font-size: 0.75rem; display: flex; align-items: center; gap: 0.25rem;">
        <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor">
          <path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6z"/>
        </svg>
        Previous
      </button>
      <button id="nextEpisodeBtn" onclick="playNextEpisode()" style="display: none; background: rgba(26, 26, 26, 0.8); border: 1px solid #444; color: white; padding: 0.3rem 0.6rem; border-radius: 0.4rem; margin-right: 0.5rem; cursor: pointer; font-size: 0.75rem; display: flex; align-items: center; gap: 0.25rem;">
        Next
        <svg viewBox="0 0 24 24" width="12" height="12" fill="currentColor">
          <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6z"/>
        </svg>
      </button>
      <button id="settingsBtn" onclick="openStreamSettings()" style="display: none; background: rgba(0, 0, 0, 0.8); border: none; color: white; padding: 6px; border-radius: 6px; cursor: pointer; margin-right: 0.5rem; border: 1px solid rgba(255, 255, 255, 0.2);">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
          <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z"/>
        </svg>
      </button>
      <div id="timeDisplay" class="text-red-400 font-mono text-sm">0:00:00</div>
      <button id="playerSettingsBtn" onclick="togglePlayerSettings()" style="background: rgba(26, 26, 26, 0.8); border: 1px solid #444; color: white; padding: 6px; border-radius: 50%; cursor: pointer; margin-left: 0.5rem; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center;">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
          <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.48l2.03,1.58C4.84,11.36,4.82,11.69,4.82,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
      </button>
      <button id="infoBtn" onclick="toggleInfoPanel()" style="background: rgba(26, 26, 26, 0.8); border: 1px solid #444; color: white; padding: 6px; border-radius: 50%; cursor: pointer; margin-left: 0.5rem; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px;">
        i
      </button>
    </div>
  </div>

  <div id="loadingText" class="loading-text">
    Loading Media With Lumina...
  </div>

  <div id="videoContainer"></div>
  <div id="progressBar">
    <div id="progressFill"></div>
  </div>

  <!-- Developer Console Panel (only visible when developer mode is enabled) -->
  <div id="developerConsole" style="position: fixed; bottom: 20px; right: 20px; width: 400px; height: 300px; background: rgba(0,0,0,0.95); border: 1px solid #8b5cf6; border-radius: 8px; z-index: 300; display: none; flex-direction: column; resize: both; overflow: hidden; min-width: 300px; min-height: 200px;">
    <div id="consoleHeader" style="background: #8b5cf6; color: white; padding: 8px 12px; cursor: move; font-weight: bold; font-size: 0.9rem; display: flex; justify-content: space-between; align-items: center;">
      <span>Developer Console</span>
      <div>
        <button onclick="clearConsole()" style="background: none; border: none; color: white; cursor: pointer; margin-right: 8px; font-size: 0.8rem;">Clear</button>
        <button onclick="toggleDeveloperConsole()" style="background: none; border: none; color: white; cursor: pointer; font-size: 1.2rem;">×</button>
      </div>
    </div>
    <div id="consoleOutput" style="flex: 1; overflow-y: auto; padding: 8px; font-family: monospace; font-size: 0.8rem; color: #e0e0e0; background: #1a1a1a; white-space: pre-wrap; word-break: break-all;"></div>
  </div>

  <div id="playerSettingsPanel" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0,0,0,0.95); padding: 2rem; text-align: left; color: white; display: none; z-index: 200; border-radius: 1rem; max-width: 400px; backdrop-filter: blur(15px); border: 1px solid rgba(139, 92, 246, 0.3);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
      <h2 style="font-size: 1.5rem; font-weight: bold; margin: 0; color: #8b5cf6;">Player Settings</h2>
      <button onclick="togglePlayerSettings()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.5rem;">×</button>
    </div>

    <div style="space-y: 1rem;">
      <div style="margin-bottom: 1.5rem;">
        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: pointer;">
          <span style="color: #b3b3b3;">Hide Navigation Buttons</span>
          <input type="checkbox" id="hideNavButtons" onchange="toggleSetting('hideNavigationButtons')" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
        </label>

        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: pointer;">
          <span style="color: #b3b3b3;">Hide Info Button</span>
          <input type="checkbox" id="hideInfoButton" onchange="toggleSetting('hideInfoButton')" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
        </label>

        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: pointer;">
          <span style="color: #b3b3b3;">Hide Settings Button</span>
          <input type="checkbox" id="hideSettingsButton" onchange="toggleSetting('hideSettingsButton')" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
        </label>

        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: pointer;">
          <span style="color: #b3b3b3;">Auto-Play Next Episode</span>
          <input type="checkbox" id="autoPlayNext" onchange="toggleSetting('autoPlayNext')" style="width: 18px; height: 18px; accent-color: #8b5cf6;" checked>
        </label>

        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: pointer;">
          <span style="color: #b3b3b3;">Minimize UI</span>
          <input type="checkbox" id="minimizeUI" onchange="toggleSetting('minimizeUI')" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
        </label>

        <label style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; cursor: pointer;">
          <span style="color: #b3b3b3;">Developer Mode</span>
          <input type="checkbox" id="developerMode" onchange="toggleSetting('developerMode')" style="width: 18px; height: 18px; accent-color: #8b5cf6;">
        </label>
      </div>

      <button onclick="resetPlayerSettings()" style="width: 100%; background: rgba(139, 92, 246, 0.2); border: 1px solid #8b5cf6; color: #8b5cf6; padding: 0.75rem; border-radius: 0.5rem; cursor: pointer; font-weight: 600;">
        Reset All Settings
      </button>
    </div>
  </div>

  <div id="infoPanel" style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0,0,0,0.9); padding: 2rem; text-align: left; color: white; display: none; z-index: 200; border-radius: 1rem; max-width: 80%; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
      <h2 style="font-size: 1.5rem; font-weight: bold; margin: 0;">Player Guide</h2>
      <button onclick="toggleInfoPanel()" style="background: none; border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 0.5rem;">×</button>
    </div>

    <div style="space-y: 1rem;">
      <div style="margin-bottom: 1rem;">
        <h3 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; color: #8b5cf6;">🖥️ Fullscreen</h3>
        <p style="margin: 0; color: #b3b3b3;">Double click the video player to enter fullscreen mode.</p>
      </div>

      <div style="margin-bottom: 1rem;">
        <h3 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; color: #8b5cf6;">📺 Episodes</h3>
        <p style="margin: 0; color: #b3b3b3;">Click the menu icon (three lines) to browse all episodes and seasons.</p>
      </div>

      <div style="margin-bottom: 1rem;">
        <h3 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; color: #8b5cf6;">⏯️ Controls</h3>
        <p style="margin: 0; color: #b3b3b3;">Use the Previous/Next buttons to navigate between episodes quickly.</p>
      </div>

      <div style="margin-bottom: 1rem;">
        <h3 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; color: #8b5cf6;">💾 Auto-Save</h3>
        <p style="margin: 0; color: #b3b3b3;">Your progress is automatically saved and will resume where you left off.</p>
      </div>

      <div>
        <h3 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; color: #8b5cf6;">🔄 Auto-Play</h3>
        <p style="margin: 0; color: #b3b3b3;">Episodes will automatically continue to the next one when finished.</p>
      </div>
    </div>
  </div>

  <div id="nextEpisodeUI">
    <img id="nextEpisodePoster" src="" alt="Next Episode" class="w-full rounded-lg mb-4" />
    <h3 id="nextEpisodeTitle" class="text-xl font-bold mb-2"></h3>
    <div>Next episode starting in <span id="nextEpisodeCountdown">10</span> seconds...</div>
  </div>

  <script>
    const API_TOKEN = "Bearer eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJkMmIwMzY4NTAyYzEwY2YyMDQ4OThiYjg3MTgyYzAxMCIsIm5iZiI6MTc0NDkyNzMyMC4yMzEsInN1YiI6IjY4MDE3YTU4MmU4OTU4ZjBmOTk5NWQ0MSIsInNjb3BlcyI6WyJhcGlfcmVhZCJdLCJ2ZXJzaW9uIjoxfQ.I22MMgWKL1X-2czV96nC49I4L3Fj_iKJm8qO_hm2GKk";
    const OMDB_API_KEY = "756f44a5";
    const BASE_URL = "https://api.themoviedb.org/3";
    const workerURL = "https://use-1-tv.rspxyum.workers.dev/";

    const watchState = {
      currentTime: 0,
      duration: 0,
      imdbID: null,
      season: 1,
      episode: 1,
      type: 'movie',
      title: '',
      poster: ''
    };

    function updateProgressBar() {
      const progress = (watchState.currentTime / watchState.duration) * 100;
      document.getElementById('progressFill').style.width = `${progress}%`;
    }

    function formatTime(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }

    function updateTimeDisplay() {
      document.getElementById('timeDisplay').innerText = formatTime(watchState.currentTime);
      updateProgressBar();
    }

    function saveProgress() {
      // Update click timestamp when saving progress
      localStorage.setItem(`lastClicked_${watchState.imdbID}`, Date.now());

      const progressData = {
        currentTime: watchState.currentTime,
        duration: watchState.duration,
        title: watchState.title,
        poster: watchState.poster,
        type: watchState.type,
        season: watchState.season,
        episode: watchState.episode,
        lastUpdated: Date.now()
      };
      localStorage.setItem(`watchProgress_${watchState.imdbID}`, JSON.stringify(progressData));
      localStorage.setItem(`lastWatched-${watchState.imdbID}`, JSON.stringify({
        episodeId: watchState.episode,
        season: watchState.season,
        timestamp: Date.now()
      }));
    }

    async function setupPostMessageHandling() {
      window.addEventListener("message", (event) => {
        if (typeof event.data === "object" && event.data.type === "PLAYER_EVENT") {
          const { currentTime, duration } = event.data.data;
          if (typeof currentTime === "number" && typeof duration === "number") {
            watchState.currentTime = currentTime;
            watchState.duration = duration;
            updateTimeDisplay();
            saveProgress();

            // Only trigger autoplay when we're very close to the end (last 25 seconds)
            if (duration > 0 && currentTime >= duration - 25 && currentTime < duration - 5) {
              handleEpisodeEnd();
            }
          }
        }
      });
    }

    async function getNextEpisodeInfo() {
      try {
        // First get TMDB ID from IMDB ID
        const findRes = await fetch(`${BASE_URL}/find/${watchState.imdbID}?external_source=imdb_id`, {
          headers: { Authorization: API_TOKEN }
        });
        const findData = await findRes.json();
        const tmdbID = findData.tv_results[0]?.id;

        if (!tmdbID) return null;

        const res = await fetch(`${BASE_URL}/tv/${tmdbID}/season/${watchState.season}`, {
          headers: { Authorization: API_TOKEN }
        });
        const data = await res.json();

        let nextEpisode = watchState.episode + 1;
        let nextSeason = watchState.season;

        if (nextEpisode > data.episodes.length) {
          nextEpisode = 1;
          nextSeason++;
          const seasonRes = await fetch(`${BASE_URL}/tv/${tmdbID}/season/${nextSeason}`, {
            headers: { Authorization: API_TOKEN }
          });
          if (!seasonRes.ok) return null;
        }

        return { season: nextSeason, episode: nextEpisode };
      } catch (error) {
        console.error("Error getting next episode:", error);
        return null;
      }
    }

    async function playNextEpisode() {
      saveProgress(); // Save before navigating
      const nextEp = await getNextEpisodeInfo();
      if (nextEp) {
        // Save next episode with guaranteed minimum progress
        const existingProgress = JSON.parse(localStorage.getItem(`watchProgress_${watchState.imdbID}`)) || {};
        const progressData = {
          currentTime: Math.max(existingProgress.currentTime || 3, 3),
          duration: existingProgress.duration || 2700,
          title: watchState.title || 'Unknown Title',
          poster: watchState.poster || 'https://via.placeholder.com/300x450?text=No+Poster',
          type: watchState.type,
          season: nextEp.season,
          episode: nextEp.episode,
          lastUpdated: Date.now()
        };
        localStorage.setItem(`watchProgress_${watchState.imdbID}`, JSON.stringify(progressData));
        localStorage.setItem(`lastWatched-${watchState.imdbID}`, JSON.stringify({
          episodeId: nextEp.episode,
          season: nextEp.season,
          timestamp: Date.now()
        }));
        localStorage.setItem(`lastClicked_${watchState.imdbID}`, Date.now());

        window.location.href = `media.html?id=${watchState.imdbID}&season=${nextEp.season}&episode=${nextEp.episode}`;
      } else {
        alert('No more episodes available');
      }
    }

    async function playPrevEpisode() {
      saveProgress(); // Save before navigating
      const prevEp = await getPrevEpisodeInfo();
      if (prevEp) {
        // Save previous episode with guaranteed minimum progress
        const existingProgress = JSON.parse(localStorage.getItem(`watchProgress_${watchState.imdbID}`)) || {};
        const progressData = {
          currentTime: Math.max(existingProgress.currentTime || 3, 3),
          duration: existingProgress.duration || 2700,
          title: watchState.title || 'Unknown Title',
          poster: watchState.poster || 'https://via.placeholder.com/300x450?text=No+Poster',
          type: watchState.type,
          season: prevEp.season,
          episode: prevEp.episode,
          lastUpdated: Date.now()
        };
        localStorage.setItem(`watchProgress_${watchState.imdbID}`, JSON.stringify(progressData));
        localStorage.setItem(`lastWatched-${watchState.imdbID}`, JSON.stringify({
          episodeId: prevEp.episode,
          season: prevEp.season,
          timestamp: Date.now()
        }));
        localStorage.setItem(`lastClicked_${watchState.imdbID}`, Date.now());

        window.location.href = `media.html?id=${watchState.imdbID}&season=${prevEp.season}&episode=${prevEp.episode}`;
      } else {
        alert('No previous episode available');
      }
    }

    async function getPrevEpisodeInfo() {
      try {
        // First get TMDB ID from IMDB ID
        const findRes = await fetch(`${BASE_URL}/find/${watchState.imdbID}?external_source=imdb_id`, {
          headers: { Authorization: API_TOKEN }
        });
        const findData = await findRes.json();
        const tmdbID = findData.tv_results[0]?.id;

        if (!tmdbID) return null;

        let prevEpisode = watchState.episode - 1;
        let prevSeason = watchState.season;

        if (prevEpisode < 1) {
          prevSeason--;
          if (prevSeason < 1) return null;

          const seasonRes = await fetch(`${BASE_URL}/tv/${tmdbID}/season/${prevSeason}`, {
            headers: { Authorization: API_TOKEN }
          });
          if (!seasonRes.ok) return null;
          const seasonData = await seasonRes.json();
          prevEpisode = seasonData.episodes.length;
        }

        return { season: prevSeason, episode: prevEpisode };
      } catch (error) {
        console.error("Error getting previous episode:", error);
        return null;
      }
    }

    async function updateNavigationButtons() {
      if (watchState.type !== 'tv') {
        document.getElementById('nextEpisodeBtn').style.display = 'none';
        document.getElementById('prevEpisodeBtn').style.display = 'none';
        return;
      }

      const nextEp = await getNextEpisodeInfo();
      const prevEp = await getPrevEpisodeInfo();

      document.getElementById('nextEpisodeBtn').style.display = nextEp ? 'block' : 'none';
      document.getElementById('prevEpisodeBtn').style.display = prevEp ? 'block' : 'none';
    }

    let episodeEndTriggered = false;

    async function handleEpisodeEnd() {
      if (episodeEndTriggered || watchState.currentTime < watchState.duration - 25) return; // Only trigger in last 25 seconds
      episodeEndTriggered = true;

      // Check if auto-play is enabled
      const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};
      const autoPlayEnabled = settings.autoPlayNext !== false; // Default true

      if (watchState.type === 'movie') {
        setTimeout(() => window.location.href = 'index.html', 2000);
        return;
      }

      const nextEp = await getNextEpisodeInfo();
      if (!nextEp) {
        setTimeout(() => window.location.href = 'index.html', 2000);
        return;
      }

      if (!autoPlayEnabled) {
        // Just show a notification instead of auto-playing
        const notification = document.createElement('div');
        notification.innerHTML = `
          <div style="position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.9); color: white; padding: 1rem; border-radius: 8px; z-index: 300;">
            Episode ended. Next episode available.
            <button onclick="this.parentElement.remove(); window.location.href='media.html?id=${watchState.imdbID}&season=${nextEp.season}&episode=${nextEp.episode}'" style="margin-left: 10px; background: #8b5cf6; border: none; color: white; padding: 0.5rem; border-radius: 4px; cursor: pointer;">Play Next</button>
            <button onclick="this.parentElement.remove()" style="margin-left: 5px; background: #666; border: none; color: white; padding: 0.5rem; border-radius: 4px; cursor: pointer;">Dismiss</button>
          </div>
        `;
        document.body.appendChild(notification);
        return;
      }

      const omdbRes = await fetch(`https://www.omdbapi.com/?i=${watchState.imdbID}&season=${nextEp.season}&episode=${nextEp.episode}&apikey=${OMDB_API_KEY}`);
      const episodeData = await omdbRes.json();

      document.getElementById('nextEpisodePoster').src = episodeData.Poster || watchState.poster;
      document.getElementById('nextEpisodeTitle').textContent = episodeData.Title;
      document.getElementById('nextEpisodeUI').style.display = 'block';

      let countdown = 10;
      const countdownInterval = setInterval(() => {
        document.getElementById('nextEpisodeCountdown').textContent = countdown;
        countdown--;

        if (countdown < 0) {
          clearInterval(countdownInterval);
          window.location.href = `media.html?id=${watchState.imdbID}&season=${nextEp.season}&episode=${nextEp.episode}`;
        }
      }, 1000);
    }

    function toggleInfoPanel() {
      const panel = document.getElementById('infoPanel');
      if (panel.style.display === 'none' || panel.style.display === '') {
        panel.style.display = 'block';
      } else {
        panel.style.display = 'none';
      }
    }

    function togglePlayerSettings() {
      const panel = document.getElementById('playerSettingsPanel');
      if (panel.style.display === 'none' || panel.style.display === '') {
        panel.style.display = 'block';
        loadPlayerSettings();
      } else {
        panel.style.display = 'none';
      }
    }

    function toggleSetting(settingName) {
      const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};
      const checkbox = document.getElementById(settingName === 'hideNavigationButtons' ? 'hideNavButtons' : 
        settingName === 'hideInfoButton' ? 'hideInfoButton' :
        settingName === 'hideSettingsButton' ? 'hideSettingsButton' :
        settingName === 'autoPlayNext' ? 'autoPlayNext' :
        settingName === 'minimizeUI' ? 'minimizeUI' :
        settingName === 'developerMode' ? 'developerMode' : settingName);

      settings[settingName] = checkbox.checked;
      localStorage.setItem('luminaSettings', JSON.stringify(settings));

      // Apply settings immediately
      applyPlayerSettings();
    }

    function loadPlayerSettings() {
      const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};

      document.getElementById('hideNavButtons').checked = settings.hideNavigationButtons || false;
      document.getElementById('hideInfoButton').checked = settings.hideInfoButton || false;
      document.getElementById('hideSettingsButton').checked = settings.hideSettingsButton || false;
      document.getElementById('autoPlayNext').checked = settings.autoPlayNext !== false; // Default true
      document.getElementById('minimizeUI').checked = settings.minimizeUI || false;
      document.getElementById('developerMode').checked = settings.developerMode || false;
    }

    function applyPlayerSettings() {
      const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};

      // Hide/show navigation buttons
      if (settings.hideNavigationButtons) {
        document.getElementById('nextEpisodeBtn').style.display = 'none';
        document.getElementById('prevEpisodeBtn').style.display = 'none';
      } else if (watchState.type === 'tv') {
        updateNavigationButtons();
      }

      // Hide/show info button
      if (settings.hideInfoButton) {
        document.getElementById('infoBtn').style.display = 'none';
      } else {
        document.getElementById('infoBtn').style.display = 'flex';
      }

      // Hide/show settings button
      if (settings.hideSettingsButton) {
        document.getElementById('playerSettingsBtn').style.display = 'none';
      } else {
        document.getElementById('playerSettingsBtn').style.display = 'flex';
      }

      // Minimize UI
      if (settings.minimizeUI) {
        document.querySelector('.caption-bar').style.background = 'linear-gradient(to bottom, rgba(15,15,15,0.7), rgba(15,15,15,0.3))';
        document.querySelector('.caption-bar').style.minHeight = '45px';
      } else {
        document.querySelector('.caption-bar').style.background = 'linear-gradient(to bottom, rgba(15,15,15,0.95), rgba(15,15,15,0.7))';
        document.querySelector('.caption-bar').style.minHeight = '60px';
      }

      // Developer Mode
      if (settings.developerMode) {
        document.getElementById('developerConsole').style.display = 'flex';
        initDeveloperConsole();
      } else {
        document.getElementById('developerConsole').style.display = 'none';
      }
    }

    function resetPlayerSettings() {
      localStorage.removeItem('luminaSettings');
      loadPlayerSettings();
      applyPlayerSettings();
      alert('Player settings have been reset to defaults.');
    }

    // Developer Console Functions
    let originalConsole = {};
    let isDragging = false;
    let dragOffset = { x: 0, y: 0 };

    function initDeveloperConsole() {
      // Intercept console methods
      if (!originalConsole.log) {
        originalConsole.log = console.log;
        originalConsole.error = console.error;
        originalConsole.warn = console.warn;
        originalConsole.info = console.info;

        console.log = function(...args) {
          originalConsole.log.apply(console, args);
          addToConsole('LOG', args);
        };

        console.error = function(...args) {
          originalConsole.error.apply(console, args);
          addToConsole('ERROR', args);
        };

        console.warn = function(...args) {
          originalConsole.warn.apply(console, args);
          addToConsole('WARN', args);
        };

        console.info = function(...args) {
          originalConsole.info.apply(console, args);
          addToConsole('INFO', args);
        };
      }

      // Make console draggable
      const consoleHeader = document.getElementById('consoleHeader');
      const consolePanel = document.getElementById('developerConsole');

      consoleHeader.addEventListener('mousedown', startDrag);
      document.addEventListener('mousemove', drag);
      document.addEventListener('mouseup', stopDrag);

      function startDrag(e) {
        isDragging = true;
        const rect = consolePanel.getBoundingClientRect();
        dragOffset.x = e.clientX - rect.left;
        dragOffset.y = e.clientY - rect.top;
        consolePanel.style.cursor = 'grabbing';
      }

      function drag(e) {
        if (!isDragging) return;

        const x = e.clientX - dragOffset.x;
        const y = e.clientY - dragOffset.y;

        // Keep within viewport bounds
        const maxX = window.innerWidth - consolePanel.offsetWidth;
        const maxY = window.innerHeight - consolePanel.offsetHeight;

        consolePanel.style.left = Math.max(0, Math.min(x, maxX)) + 'px';
        consolePanel.style.top = Math.max(0, Math.min(y, maxY)) + 'px';
        consolePanel.style.right = 'auto';
        consolePanel.style.bottom = 'auto';
      }

      function stopDrag() {
        isDragging = false;
        consolePanel.style.cursor = 'default';
      }
    }

    function addToConsole(type, args) {
      const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};
      if (!settings.developerMode) return; // Don't log if developer mode is disabled

      const output = document.getElementById('consoleOutput');
      if (!output) return;

      const timestamp = new Date().toLocaleTimeString();
      const message = args.map(arg => 
        typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
      ).join(' ');

      const color = {
        'LOG': '#e0e0e0',
        'ERROR': '#ff6b6b',
        'WARN': '#ffd93d',
        'INFO': '#74c0fc'
      }[type] || '#e0e0e0';

      const logEntry = `[${timestamp}] ${type}: ${message}\n`;
      const span = document.createElement('span');
      span.style.color = color;
      span.textContent = logEntry;

      output.appendChild(span);
      output.scrollTop = output.scrollHeight;
    }

    function clearConsole() {
      const output = document.getElementById('consoleOutput');
      if (output) {
        output.innerHTML = '';
      }
    }

    function toggleDeveloperConsole() {
      const console = document.getElementById('developerConsole');
      const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};

      if (console.style.display === 'none') {
        console.style.display = 'flex';
        settings.developerMode = true;
        document.getElementById('developerMode').checked = true;
      } else {
        console.style.display = 'none';
        settings.developerMode = false;
        document.getElementById('developerMode').checked = false;
      }

      localStorage.setItem('luminaSettings', JSON.stringify(settings));
    }

    function openStreamSettings() {
      const params = new URLSearchParams(window.location.search);
      const imdbID = params.get("id");
      window.location.href = `stream.html?imdb=${imdbID}&type=tv`;
    }

    async function setupPlayer() {
      const params = new URLSearchParams(window.location.search);
      watchState.imdbID = params.get("id");
      watchState.season = parseInt(params.get("season")) || 1;
      watchState.episode = parseInt(params.get("episode")) || 1;
      watchState.type = params.get("type") || (params.get("season") ? 'tv' : 'movie');

      if (!watchState.imdbID) return;

      try {
        // Get show/movie details first
        const omdbRes = await fetch(`https://www.omdbapi.com/?i=${watchState.imdbID}&apikey=${OMDB_API_KEY}`);
        const mediaData = await omdbRes.json();
        watchState.title = mediaData.Title || 'Unknown Title';
        watchState.poster = mediaData.Poster || 'https://via.placeholder.com/300x450?text=No+Poster';

        // IMMEDIATELY auto-save media progress BEFORE player loads to ensure cards never disappear
        const existingProgress = JSON.parse(localStorage.getItem(`watchProgress_${watchState.imdbID}`)) || {};
        const progressData = {
          currentTime: Math.max(existingProgress.currentTime || 5, 5), // Auto-set to 5 seconds minimum
          duration: existingProgress.duration || (watchState.type === 'tv' ? 2700 : 6300), // 45min for TV, 105min for movies
          title: watchState.title,
          poster: watchState.poster,
          type: watchState.type,
          season: watchState.season,
          episode: watchState.episode,
          lastUpdated: Date.now()
        };
        localStorage.setItem(`watchProgress_${watchState.imdbID}`, JSON.stringify(progressData));

        // Force update current time in state immediately
        watchState.currentTime = progressData.currentTime;
        watchState.duration = progressData.duration;
        updateTimeDisplay();

        if (watchState.type === 'tv' || params.get("season")) {
          localStorage.setItem(`lastWatched-${watchState.imdbID}`, JSON.stringify({
            episodeId: watchState.episode,
            season: watchState.season,
            timestamp: Date.now()
          }));

          // Check settings to show/hide navigation buttons
          const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};

          if (!settings.hideNavigationButtons) {
            await updateNavigationButtons();
          }

          // Show settings gear based on settings
          if (!settings.hideSettingsButton) {
            document.getElementById('settingsBtn').style.display = 'flex';
          }
        }

        // Check settings for info button
        const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};
        if (settings.hideInfoButton) {
          document.getElementById('infoBtn').style.display = 'none';
        }

        // Always update last clicked to ensure card priority
        localStorage.setItem(`lastClicked_${watchState.imdbID}`, Date.now());

        const edgeUrl = await getEdgeUrl(watchState.imdbID, watchState.season, watchState.episode);

        const iframe = document.createElement("iframe");
        iframe.src = edgeUrl;
        iframe.id = "movieIframe";
        iframe.setAttribute("referrerpolicy", "origin");
        iframe.setAttribute("sandbox", "allow-scripts allow-same-origin allow-presentation allow-popups");
        iframe.setAttribute("allow", "fullscreen; autoplay; encrypted-media");

        document.getElementById("videoContainer").appendChild(iframe);
        document.getElementById('loadingText').style.display = 'none';

        // Restore progress and force autoplay
        const savedProgress = JSON.parse(localStorage.getItem(`watchProgress_${watchState.imdbID}`));

        // Wait for player to be ready
        setTimeout(() => {
          if (savedProgress && savedProgress.currentTime > 0) {
            iframe.contentWindow.postMessage(
              JSON.stringify({ player: true, action: `seek+${savedProgress.currentTime}` }), '*'
            );
          }

          // Force autoplay after seeking
          setTimeout(() => {
            iframe.contentWindow.postMessage(
              JSON.stringify({ player: true, action: 'play' }), '*'
            );
          }, 1000);
        }, 2000);

        // Check time more frequently for better accuracy
        setInterval(() => {
          iframe.contentWindow.postMessage(
            JSON.stringify({ player: true, action: 'time' }), '*'
          );
        }, 250);

      } catch (error) {
        console.error("Error setting up player:", error);
        document.getElementById('loadingText').textContent = "Failed to load media";
      }
    }

    async function getEdgeUrl(imdbID, season, episode) {
      const response = await fetch(`${workerURL}?id=${imdbID}&season=${season}&episode=${episode}`);
      if (!response.ok) throw new Error("Failed to fetch edge URL");
      const data = await response.json();
      return data.edgeUrl;
    }

    // Monitor iframe for /srcrcp/ URLs and redirect if found
    function monitorIframeSrc() {
      const iframe = document.getElementById('player_iframe');
      console.log('Monitoring iframe src:', iframe ? iframe.src : 'iframe not found');

      if (iframe && iframe.src && iframe.src.includes('/srcrcp/')) {
        console.log('Detected /srcrcp/ URL, redirecting to Google teapot');
        iframe.src = 'https://www.google.com/teapot';
      }
    }

    // Monitor videoContainer iframes for URL length and show 404 loop if too long
    function monitorVideoContainerIframes() {
      const videoContainer = document.getElementById('videoContainer');
      if (!videoContainer) {
        const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};
        if (settings.developerMode) {
          console.log('Video container not found');
        }
        return;
      }

      const iframes = videoContainer.querySelectorAll('iframe');
      const settings = JSON.parse(localStorage.getItem('luminaSettings')) || {};

      if (settings.developerMode) {
        console.log(`Found ${iframes.length} iframe(s) in videoContainer`);
      }

      iframes.forEach((iframe, index) => {
        const src = iframe.src || '';

        if (settings.developerMode) {
          console.log(`Iframe ${index + 1} current src: ${src.substring(0, 150)}${src.length > 150 ? '...' : ''}`);
        }

        // FIRST: Wait for cloudnestra URL to appear
        if (!src.includes('cloudnestra.com')) {
          if (settings.developerMode) {
            console.log(`Iframe ${index + 1}: Waiting for cloudnestra URL...`);
          }
          return; // Skip if not a cloudnestra URL yet
        }

        // SECOND: Once we have cloudnestra URL, check character length
        if (settings.developerMode) {
          console.log(`Iframe ${index + 1}: Found cloudnestra URL, checking length (${src.length} characters)`);
        }

        if (src.length < 1500) {
          if (settings.developerMode) {
            console.log(`Iframe ${index + 1}: URL too short (${src.length} chars), removing iframe and showing error`);
          }

          // Only show content unavailable for valid media pages
          const params = new URLSearchParams(window.location.search);
          const hasValidMediaParams = params.get("id");

          // Remove the iframe
          iframe.remove();

          // Show error message only if this is a valid media page
          if (hasValidMediaParams) {
            const loadingText = document.getElementById('loadingText');
            if (loadingText && loadingText.textContent.includes('Loading Media With Lumina')) {
              loadingText.innerHTML = `
                <div style="text-align: center;">
                  <h2 style="color: #ff6b6b; margin-bottom: 1rem;">Content Unavailable</h2>
                  <p style="color: #ffffff; font-size: 1.2rem;">Unfortunately, Lumina doesn't have this content available right now.</p>
                  <p style="color: #b3b3b3; margin-top: 1rem;">We apologize for the inconvenience and are working to expand our library.</p>
                  <button onclick="window.history.back()" style="margin-top: 2rem; background: #8b5cf6; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; font-size: 1rem;">
                    Go Back
                  </button>
                </div>
              `;
              loadingText.style.display = 'block';
            }
          }
        } else {
          if (settings.developerMode) {
            console.log(`Iframe ${index + 1}: URL length OK (${src.length} chars)`);
          }
        }
      });
    }

    document.addEventListener("DOMContentLoaded", () => {
      setupPostMessageHandling();
      setupPlayer();

      // Apply saved settings immediately
      setTimeout(() => {
        applyPlayerSettings();
      }, 100);

      // Start monitoring iframe src every second
      setInterval(monitorIframeSrc, 1000);

      // Start monitoring videoContainer iframes every second
      setInterval(monitorVideoContainerIframes, 1000);
    });

    // Save progress when navigating away from the page
    window.addEventListener("beforeunload", () => {
      saveProgress();
    });

    // Save progress when page becomes hidden (mobile browsers)
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) {
        saveProgress();
      }
    });
  </script>
</body>
</html>
